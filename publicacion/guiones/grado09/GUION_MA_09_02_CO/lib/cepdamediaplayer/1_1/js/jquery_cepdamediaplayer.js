/************************************************************************
 *
 * CEPDA Media Player - jQuery plugin basado en Acorn Media Player
 *
 * Versión 15.02.19.1
 *
 * Autores Acorn Media Player: www.ghinda.net 
 *														(stephenoldham y leslash en github.com)
 * Autor versión actual: Javier Garcés - Sinergia sistemas informáticos
 *
 ************************************************************************/

// Inicialización del plugin JQuery
(function($) {
	
	/*
	 * Función a la que debemos llamar desde jquery
	 */
	$.fn.cepdaMediaPlayer = function(options) {
		
		/*
		 * Definimos las opciones por defecto del plugin
		 */
		var defaults = {
			theme: 'planeta',							// Tema
			volumeSlider: 'horizontal',		// Tipo de slider para volumen (vertical u horizontal)
			captionsOn: true,							// Mostramos los subtítulos si los tiene
			autoplayOn: true,							// Reproducimos el vídeo nada más crearlo
			bigBtnOn: true,								// Ponemos el botón BIG Play
			saveVolumeOn: false,					// No guardamos el nivel de volumen entre sesiones
			nativeSliders: false,					// No usamos sliders nativos
			fullScreenRelocateOn: false,	// Recolocamos en el DOM el elemento para que en fullscreen esté en el body y evite problemas de escalado
			texts:{												// Textos de los botones 
				play: 'Play',
				playTitle: 'Start the playback',
				pause: 'Pause',
				pauseTitle: 'Pause the playback',
				mute: 'Mute',
				unmute: 'Unmute',
				fullscreen: 'Fullscreen',
				fullscreenTitle: 'Toggle fullscreen mode',
				volumeTitle: 'Volume control',
				seekTitle: 'Video seek control',
				captions: 'Captions',
				captionsTitle: 'Show captions'
			}
		};
		// Extendemos las opciones por defecto con las que nos pasan
		options = $.extend(defaults, options);

		/*
		 * Función para generar un identificador único a partir de la fecha y hora
		 * Se usa para generar un Id por cada tag de media (vídeo o audio) que encontremos
		 */
		var uniqueID = function() {
			var currentDate = new Date();
			return currentDate.getTime();
		};

		/*
		 * Debug
		 */
		function debugLog(string) {
			var da = document.getElementById("debug");
			if (da) {
				da.value += string + "\n";
				da.scrollTop = da.scrollHeight;				
			}
		}

		/*
		* Detección básica de algunos aspectos de compatibilidad (pantalla tactil, casos de navegadores determinados, etc)
		*/
		// Detección de Flash (basada en SWFObject 2.2)
		function hasAdobeFlash() {
      var SHOCKWAVE_FLASH = "Shockwave Flash",
          SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
          FLASH_MIME_TYPE = "application/x-shockwave-flash";
			
			try {
				var d = null;
				if (typeof navigator.plugins != "undefined" && typeof navigator.plugins[SHOCKWAVE_FLASH] == "object") {
	        d = navigator.plugins[SHOCKWAVE_FLASH].description;
	        if (d && !(typeof navigator.mimeTypes != "undefined" && navigator.mimeTypes[FLASH_MIME_TYPE] && !navigator.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) { // navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
	        	return true;
	      	}
				}
				else if (typeof win.ActiveXObject != "undefined") {
	        try {
	          var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
	          if (a) { // a will return null when ActiveX is disabled
	            d = a.GetVariable("$version");
	            if (d) {
	    					return true;
	            }
	          }
	        }
	        catch(e) {}
				}
			} catch(e) {}
			return false;
		}
		
		// Detección de soporte para LocalStorage (para guardarnos el volumen)
		function hasLocalStorage() {
			try {
				return 'localStorage' in window && window.localStorage !== null;
			} catch(e){
				return false;
			}
		}

		// VARIABLES QUE NOS INDICAN QUE CARACTERISTICAS TENEMOS DISPONIBLES PARA EL NAVEGADOR
		// Es dispositivo de touch
		var is_touch_device = 'ontouchstart' in document.documentElement;
		// Es un navegador Chrome para Android
		var is_android_chrome_browser = (/Android/i.test(navigator.userAgent)) && (/Chrome/i.test(navigator.userAgent)); // Pone su propio BIG Play
		// Es un navegador nativo de Android (el antiguo)
		var is_android_os_browser = (/Android/i.test(navigator.userAgent)) && !(/Chrome/i.test(navigator.userAgent)); ; // Pone su propio BIG Play
		// Es un dispositivo iOS
		var is_ios_browser = (/iPhone|iPad|iPod/i.test(navigator.userAgent));
		// Es un navegador IE para windows
		var is_windows_ie_browser = (/Windows/i.test(navigator.userAgent)) && (/Trident/i.test(navigator.userAgent))
		// Tiene plugin de flash
		var has_adobe_flash = hasAdobeFlash();
		// Soporta local storage
		var supports_local_storage = hasLocalStorage();
		
		// No tiene soporte nativo vídeo HTML5
		var cant_use_html5_video = !document.createElement('video').canPlayType;
		// No puede manejar el volumen (iOS)
		var cant_manage_volume = is_ios_browser; // Sin soporte de control de volumen
		// No puede mostar el BIG play porque resulta que el propio navegador ya pone uno y no lo quita nunca
		var cant_show_big_play = is_android_chrome_browser || is_android_os_browser;
		// No puede usar el modo fullscreen nativo aunque el api lo soporte (por ejemplo, porque quita subtítulos o controles)
		// NOTA (11/7/2014): Lo desactivamos porque cuando el player va dentro de un IFRAME nunca puede hacer
		//                   fullscreen nativo
		var cant_go_fullscreen = true; //is_windows_ie_browser || is_ios_browser || is_android_chrome_browser || is_android_os_browser;

		debugLog("cant_use_html5_video: " + cant_use_html5_video);
		debugLog("cant_manage_volume: " + cant_manage_volume);
		debugLog("cant_show_big_play: " + cant_show_big_play);
		debugLog("cant_go_fullscreen: " + cant_go_fullscreen);
		debugLog("has_adobe_flash: " + has_adobe_flash);

		/*********************************************************************************************************
				MODO VIDEO FLASH (para cuando no hay compatibilidad vídeo nativo HTML5)
		**********************************************************************************************************/

		/* cant_use_html5_video = false; */

		// Miramos si tenemos soporte de vídeo HTML5 nativo
		if (cant_use_html5_video) {
			
			/*
			 * Función principal del plugin cuando ha de usar FLASH (pseudo-constructor)
			 * Se la llamará para cada elemento video o audio que queramos customizar
			 */
			var cepdaFlashPlayer = function() {
				// Creamos el objeto cepda, que será el que usaremos como raíz para las
				// referencias a todos los elementos a manipular del vídeo/audio
				var cepda = {
					$self: $(this)
				};
				
				/*
				 * Miramos si hay la media tiene ID.
				 * Si no tiene, generamos uno que sea único
				 */
				cepda.id = cepda.$self.attr('id');
				if(!cepda.id) {
					cepda.id = 'cepda' + uniqueID();
					cepda.$self.attr('id', cepda.id);
				}
	
				/* VERSION QUE CONSTRUYE EL TAG COMPLETO PARA FLASH
				var videoSource = $("source[type='video/mp4']", cepda.$self).attr('src');
				var videoSubs = $("track", cepda.$self).attr('src');
				var videoWidth = cepda.$self.attr('width');
				var videoHeight = cepda.$self.attr('height');
				var videoClass = cepda.$self.attr('class');
				var videoStyle = cepda.$self.attr('style');
				
				var flashMarkup = '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="' + videoWidth + '" height="' + videoHeight + '">\n' +
	    										'	<param name="allowScriptAccess" value="sameDomain" />\n' +
	    										'	<param name="allowFullScreen" value="true" />\n' +
	    										'	<param name="movie" value="pppVideoPlayer.swf" />\n' +
	    										'	<param name="quality" value="high" />\n' +
	    										'	<param name="wmode" value="transparent">\n' +
													'	<param name="FlashVars" value="ruta_flv=' + encodeURIComponent(videoSource);
				if (videoSubs != null && videoSubs != undefined && videoSubs != "") {
					flashMarkup +=			'&ruta_srt=' + encodeURIComponent(videoSubs);
				}
				flashMarkup +=				'">\n' +
	    										'	<embed src="pppVideoPlayer.swf" width="' + videoWidth + '" height="' + videoHeight + '" quality="high" allowScriptAccess="sameDomain" allowFullScreen="true" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" wmode="transparent" ' +
	    										'flashvars="ruta_flv=' + encodeURIComponent(videoSource);
				if (videoSubs != null && videoSubs != undefined && videoSubs != "") {
					flashMarkup +=			'&ruta_srt=' + encodeURIComponent(videoSubs);
				}
				flashMarkup +=				'"/>\n' +
													'</object>\n';
													
				// Contenedor de los media. Básicamente, lo que se hace es sacar el vídeo/audio del DOM
				// poner este contenedor en su lugar, y dentro de éste volver a colocar el vídeo/audio
				// junto con los controles, el botón BIG Play y otros elementos.
				var $wrapper = $(flashMarkup);
				// Nos aseguramos que sea visible
				//$wrapper.css('visibility','visible');
				
				// Montamos el HTML Markup definitivo
				// Añadimos el contenedor
				cepda.$self.after($wrapper);
	
				// Quitamos la media real y nos quedamos con el nuevo media/video dentro del contenedor
				cepda.$self.remove();
				cepda.$self = $wrapper.find('object');
				*/
				
				// VERSION QUE SIMPLEMENTE EXTRAE EL TAG DE COMPATIBILIDAD Y LO PONE FUERA DEL TAG DE VIDEO
				// LA GRAN VENTAJA QUE TIENE ES QUE MANTIENE LOS ESTILOS Y OTROS DETALLES PUESTOS EN EL TAG
				// OBJECT DE COMPATIBILIDAD, CON LO QUE EL HTML MANTIENE TODO EL CONTROL EN CUANTO AL ESTILO
				// DEL FLASH SUBSTITUTO.
				// Obtenemos el tag "object" del Flash
				var $flashObject = $("object", cepda.$self);
				// Lo sacamos del DOM
				$flashObject.detach();
				// Lo volvemos a añadir tras el tag de vídeo
				cepda.$self.after($flashObject);
				// Nos cargamos el tag de vídeo
				cepda.$self.remove();
				// Hacemos que $self apunte ahora al objeto Flash
				cepda.$self = $flashObject;
				
			}
			
			// Hacemos este proceso por todos los elementos que cumplan con el criterio de incialización
			// para que acaben siendo un plugin de Flash y lo dejamos así.
			return this.each(cepdaFlashPlayer);
		}

		/*********************************************************************************************************
				MODO VIDEO NATIVO HTML5
		**********************************************************************************************************/

		/*
		 * Obtenemos el volumen del LocalStorage, si lo hay. Si no, lo ponemos al máximo
		 */
		var volume = (supports_local_storage && options.saveVolumeOn) ? localStorage.getItem('cepdavolume') : 1;
		if(!volume) {
			volume = 1;
		}

		/*
		 * Función principal del plugin (pseudo-constructor)
		 * Se la llamará para cada elemento video o audio que queramos customizar
		 */
		var cepdaPlayer = function() {
			// Creamos el objeto cepda, que será el que usaremos como raíz para las
			// referencias a todos los elementos a manipular del vídeo/audio
			var cepda = {
				$self: $(this)
			};
			
			// Variables privadas
			var loadedMetadata; // Indica si se ha cargado las metadata
			var seeking; // Indica que se está en proceso de seek 
			var wasPlaying; // Indica si se estaba reproduciendo cuando se comenzó el seek
			var fullscreenMode; // Indica si estamos en modo fullscreen
			var hasCaptions;		// Indica que hay subtítulos
			var captionsActive; // Indica si los subtitulos están activos

			// Deshabilitamos el autoplay nativo para usar nuestra opción de autoplay
			cepda.$self.prop('autoplay', false);


			// Contenedor de los media. Básicamente, lo que se hace es sacar el vídeo/audio del DOM
			// poner este contenedor en su lugar, y dentro de éste volver a colocar el vídeo/audio
			// junto con los controles, el botón BIG Play y otros elementos.
			var $wrapper = $('<div class="cepda-player" role="application"></div>').addClass(options.theme);

			/*
			 * Miramos si hay la media tiene ID.
			 * Si no tiene, generamos uno que sea único
			 */
			cepda.id = cepda.$self.attr('id');
			if(!cepda.id) {
				cepda.id = 'cepda' + uniqueID();
				cepda.$self.attr('id', cepda.id);
			}

			/*
			 * HTML Markup del botón de FullScreen
			 * Si no es un vídeo (es un audio, vaya), queda en blanco
			 */
			var fullscreenBtnMarkup = (cepda.$self.is('video')) ? '<button class="cepda-fullscreen-button" title="' + options.texts.fullscreenTitle + '">' + options.texts.fullscreen + '</button>' : '';

			/*
			 * Template HTML general para una barra de control clásica
			 */
			var template = '<div class="cepda-controls">' +
								'<button class="cepda-play-button" title="' + options.texts.playTitle + '">' + options.texts.play + '</button>' +
								'<input type="range" class="cepda-seek-slider" title="' + options.texts.seekTitle + '" value="0" min="0" max="150" step="0.1"/>' +
								'<span class="cepda-timer">00:00</span>' +
								'<div class="cepda-volume-box">' +
									'<button class="cepda-volume-button" title="' + options.texts.mute + '">' + options.texts.mute + '</button>' +
									'<input type="range" class="cepda-volume-slider" title="' + options.texts.volumeTitle + '" value="1" min="0" max="1" step="0.05"/>' +
								'</div>' +
								fullscreenBtnMarkup +
								'<button class="cepda-caption-button" title="' + options.texts.captionsTitle + '">' + options.texts.captions + '</button>' +
							'</div>';

			// Si en las opciones tenemos una plantilla alternativa (a través de la función onToolbarTemplate),
			// entonces generamos la pantilla a partir de las opciones que nos han pasado
			if (options.onToolbarTemplate) {
				template = options.onToolbarTemplate(cepda, options);
			}
			
			// HTML Markup para los subtítulos
			var captionMarkup = '<div class="cepda-caption"></div>';

			/*
			 * Montamos el HTML Markup definitivo
			 */

			// Añadimos el contenedor
			cepda.$self.after($wrapper);

			// IMPORTANTE: BUG iOS y BUG Chrome
			// - BUG iOS: Para soportar iOS, debemos clonar el nodo y eliminar el original y obtener una referencia al nuevo.
			// Esto se ha de hacer porque iOS no reproduce vídeos que han sido "recolocados".
			// Mirar: http://bugs.jquery.com/ticket/8015
			// - BUG Chrome: Si se clona de vídeo/audio el nodo en vez de simplemente moverlo, ésto provoca que no se carguen
			//   bien los metadatos y el vídeo se quede esperando indefinidamente.
			// - BUG general Audios: Si recolocamos el audio, en vez de clonarlo, no recibimos evento de metadata...
			// Debemos tener en cuenta estos temas:
			// Si es iOS o es un audio, clonamos el nodo
			if (/*is_ios_browser || cepda.$self.is('audio')*/true) {
				$wrapper[0].appendChild( cepda.$self[0].cloneNode(true) );
				// Quitamos la media real y nos quedamos con el nuevo media/video dentro del contenedor
				cepda.$self.remove();
				cepda.$self = $wrapper.find('video, audio');
			}
			// Si no es iOS, lo "movemos" en el DOM
			else {
				$wrapper[0].appendChild(cepda.$self[0]);
			}
			
			// Añadimos los controles, el BIG Play (si lo soporta) y la máscara de cargando
			cepda.$self.after(template);
			if (options.bigBtnOn && !cant_show_big_play)
				cepda.$self.after('<div class="cepda-bigbutton"></div>');
			cepda.$self.after('<div class="loading-media"></div>');

			// Nos quedamos con las referencias a todos los elementos DOM importantes
			// del DOM que hemos creado con las marcas para poderlos manipular
			// posteriormente
			cepda.$container = cepda.$self.parent('.cepda-player');
			cepda.$controls = $('.cepda-controls', cepda.$container);
			cepda.$playBtn = $('.cepda-play-button', cepda.$container);
			cepda.$seek = $('.cepda-seek-slider', cepda.$container);
			cepda.$timer = $('.cepda-timer', cepda.$container);
			cepda.$volume = $('.cepda-volume-slider', cepda.$container);
			cepda.$volumeBtn = $('.cepda-volume-button', cepda.$container);
			cepda.$fullscreenBtn = $('.cepda-fullscreen-button', cepda.$container);
			
			// El BIG Play, si la opción está activa.
			if (options.bigBtnOn && !cant_show_big_play) {
				cepda.$bigBtn = $('.cepda-bigbutton', cepda.$container);
				// Ajusto la altura del playbutton
				cepda.$bigBtn.css('height', /*cepda.$self.height() + 'px'*/'100%');
			}

			// Añadimos finalmente el Markup de subtítulos
			// que van un poco por libre (subs dentro del contenedors)
			cepda.$controls.after(captionMarkup);

			// Nos quedamos con las referencias a los elementos DOM de los subtítulos
			cepda.$caption = $('.cepda-caption', cepda.$container);
			cepda.$captionBtn = $('.cepda-caption-button', cepda.$container);

			// Vinculamos el objeto cepda al elementoDOM
			cepda.$self.data('cepdaPlayer', cepda);
			/*
			 * Rutina para formatear el tiempo en "minutos:segundos". 
			 * Recibe el nº de segundos.
			 * Se usa junto a "currentTime"
			 */
			var timeFormat = function(sec) {
				var m = Math.floor(sec/60)<10?"0" + Math.floor(sec/60):Math.floor(sec/60);
				var s = Math.floor(sec-(m*60))<10?"0" + Math.floor(sec-(m*60)):Math.floor(sec-(m*60));
				return m + ":" + s;
			};

			/*
			 * Comportamiento de PLAY/PAUSE
			 *
			 * Function for the Play button
			 * Lanza los eventos nativods de Play o Pause. De esta manera, el control de los botones
			 * está siempre sincronizado con el funcionamiento real del vídeo
			 */
			var playMedia = function() {
				// Si no estaba en pausa, lo pone en pausa
				if(!cepda.$self.prop('paused')) {
					cepda.$self.trigger('pause');
				} else { // Si estaba en pausa, lo pone en marcha
					cepda.$self.trigger('play');
					// Quitamos el boton grande si es necesario
					if (cepda.$bigBtn) {
						if (cepda.$bigBtn.css('visibility') != 'hidden') {
							cepda.$bigBtn.css('opacity','0');
							setTimeout( function () {
								cepda.$bigBtn.css('visibility','hidden');
							}, 700); // Deja un tiempo para que se pueda hacer el efecto fadeout del botón
						}
					}
					// Habilitamos el botón de fullscreen si es necesario, que por defecto está
					// inhabilitado hasta que comience la reproducción.
					if (cepda.$fullscreenBtn.prop('disabled') == true) {
						cepda.$fullscreenBtn.prop('disabled', false);
					}
				}
				return false;
			};
			
			/*
			 * Funciones para gestionar los eventos de Play, Pause y Ended de la media.
			 * Aquí es realmente donde ponemos los estados de los botones de la toolbar, de manera
			 * que siempre están sincronizados con la media. Así pues, aún usando los mandos 
			 * "nativos" del menú contextual (por ejemplo), la toolbar seguiría sincronizada
			 */
			var startPlayback = function() {
				// Cambiamos el texto y clase del botón para que ponga el modo pause
				cepda.$playBtn.text(options.texts.pause).attr('title', options.texts.pauseTitle);
				cepda.$playBtn.addClass('cepda-paused-button');

				// Si todavía no se ha cargado la metada, mostramos la máscara de cargando
				if(!loadedMetadata) $wrapper.addClass('show-loading');
			};

			var stopPlayback = function() {
				// Recuperamos el boton play original
				cepda.$playBtn.text(options.texts.play).attr('title', options.texts.playTitle);
				cepda.$playBtn.removeClass('cepda-paused-button');
			};

			/*
			 * Comportamiento del SLIDER de SEEK
			 *
			 * Actualiza tanto el contador de tiempo como la barra del slider
			 * Se llama en cada evento "timeUpdate" que nos llega
			 */
			var seekUpdate = function() {
				var currenttime = cepda.$self.prop('currentTime');
				cepda.$timer.text(timeFormat(currenttime));

				// Si estamos forzando seek manualmente
				if(!seeking) {
					// Actualizamos el slider
					if (options.nativeSliders) {
						//cepda.$seek.val(currenttime);
						cepda.$seek[0].value = currenttime;
					} else {
						cepda.$seek.slider('value', currenttime);
					}
				}

				// Si tenemos subtítulos, los actualizamos
				if(captionsActive) {
					updateCaption();
				}
			};

			/*
			 * El slider de jQuery usa preventDefault cuando se clica sobre cualquier elemento
			 * lo que hace que el botón activo no pierda el foco.
			 * Esto causa problemas con la selección de subtítulos.
			 * Hay que lanzar el blur manualmente.
			 */
			var blurCaptionBtn = function() {
				cepda.$captionBtn.trigger('blur');
			};

			/*
			 * Lanzado cuando el usuario inicia un seek manualmente
			 * Pausa la media durante el seek y cambia el "currentTime" del slider al nuevo valor
			 */
			var startSeek = function(e, ui) {
/*
				if (seeking == true)
					return;
*/

				if(!cepda.$self.prop('paused')) {
					wasPlaying = true;
				}
				cepda.$self.trigger('pause');
				seeking = true;

				var seekLocation;
				if (options.nativeSliders) {
					seekLocation = cepda.$seek.val();
				} else {
					seekLocation = ui.value;
				}


				cepda.$self.prop('currentTime', seekLocation);

				// forzamos el blur sobre el botón de subtítulos
				blurCaptionBtn();
			};

			/*
			 * Lanzado cuando el usuario acaba de hacer seek manualmente
			 * Si la media estaba reproduciéndose, la pone en marcha de nuevo
			 */
			var endSeek = function(e, ui) {
/*
				if (seeking == false)
					return;
*/
				if(wasPlaying) {
					if (options.nativeSliders) {
						setTimeout(function() {
					cepda.$self.trigger('play');
						},100);
					} else {
						cepda.$self.trigger('play');
					}
					wasPlaying = false;
				}
				seeking = false;
			};

			/*
			 * Inicializar el slider jQuery
			 */
			var initSeek = function() {

				// obtener las clases actuales
				var seekClass = cepda.$seek.attr('class');

				// crear el markup html final necesario y ponerlo en lugar del actual
				var	divSeek = '<div class="' + seekClass + '" title="' + options.texts.seekTitle + '"></div>';
				cepda.$seek.after(divSeek).remove();

				// obtener el nuevo elemento seek definitivo
				cepda.$seek = $('.' + seekClass, cepda.$container);

				// Creamos el elemento que hará de buffer visual
				var bufferBar = '<div class="ui-slider-range cepda-buffer"></div>';
				cepda.$seek.append(bufferBar);

				// obtener el elemento DOM que hará de buffer
				cepda.$buffer = $('.cepda-buffer', cepda.$container);

				// Ponemos las opciones propias de un slider jQuery
				var sliderOptions = {
					value: 0,
					step: 1,
					orientation: 'horizontal',
					range: 'min',
					min: 0,
					max: 100
				};
				// inicializamos el slider jQuery
				cepda.$seek.slider(sliderOptions);

			};

			/*
			 * Actualizar el slider de Seek, una vez tenemos los metadatos de la media cargados
			 * Vinculamos eventos, añadimos el atributo "duration" y generamos el slider jQuery
			 */
			var updateSeek = function() {
				// Obtenemos la duración de la media
				var duration = cepda.$self.prop('duration');

				// Check for the nativeSliders option
				if(options.nativeSliders) {
					cepda.$seek.attr('max', duration);
					//use input instead of change event (see: https://github.com/aFarkas/webshim/issues/297)
					cepda.$seek.bind('change', function() { startSeek(); endSeek(); }); // Change es como startseek y stopseek
					cepda.$seek.bind('mousedown', function() { debugLog("SEEK DOWN"); startSeek(); });
					cepda.$seek.bind('mouseup', function() { debugLog("SEEK UP"); endSeek(); });
				} else {
				// Ponemos las opciones para el slider jQuery
				var sliderOptions = {
					value: 0,
					step: 1,
					orientation: 'horizontal',
					range: 'min',
					min: 0,
					max: duration,
					slide: startSeek,
					stop: endSeek,
					label: 'Video seek control'
				};
				// inicializamos el slider jQuery
				cepda.$seek.slider('option', sliderOptions);
					if (isNaN(duration) == false)
						cepda.$seek.slider( "option", "max", duration );
					debugLog("ACTUALIZANDO MAX: " + duration + " - " + cepda.$seek.slider( "option", "max"));

				// Quitar el foco del botón de subtítulos manualmente cuando se clique el handle del slider
				$('.ui-slider-handle', cepda.$seek).click(blurCaptionBtn);

				// Vinculamos el avance del vídeo con el elemento DOM de buffer
				cepda.$self.bind('progress', showBuffer);
				}

				// Quitamos el loading
				$wrapper.removeClass('show-loading');

			};

			/*
			 * Rutina para actualizar el tamaño del buffer en el slider según el progreso de la media
			 */
			var showBuffer = function(e) {
				var max = parseInt(cepda.$self.prop('duration'), 10);
				var tr = cepda.$self.prop('buffered');
				if(tr && tr.length) {
					var buffer = parseInt(tr.end(0) - tr.start(0), 10);
					var bufferWidth = (buffer*100)/max;

					cepda.$buffer.css('width', bufferWidth + '%');
				}
			};

			/*
			 * Evento de cambio de volumen. Comportamiento del botón de volumen y su slider
			 *
			 * Cambiar el volumen a través del slider y usar el localStorage para guardar el volumen entre sesiones
			 */
			var changeVolume = function(e, ui) {
				// Obtenemos el valor actual del volumen
				volume = ui.value;
				// lo guardamos en el localStorage
				if (supports_local_storage && options.saveVolumeOn)
					localStorage.setItem('cepdavolume', volume);

				// Miramos si el volumen estaba "muted" antes
				if(cepda.$self.prop('muted')) {
					cepda.$self.prop('muted', false);
					cepda.$volumeBtn.removeClass('cepda-volume-mute');
					cepda.$volumeBtn.text(options.texts.mute).attr('title', options.texts.mute);
				}

				// ponemos el nuevo volumen en a media
				cepda.$self.prop('volume', volume);

				// manually trigger the Blur event on the Caption Button
				blurCaptionBtn();
			};

			/*
			 * Mute y Unmute del volumen
			 * También añadir clases y cambiar el label del volumen en el botón
			 */
			var muteVolume = function() {
				if(cepda.$self.prop('muted') === true) {
					cepda.$self.prop('muted', false);
					if(options.nativeSliders) {
						cepda.$volume.val(volume);
					} else {
					cepda.$volume.slider('value', volume);
					}

					cepda.$volumeBtn.removeClass('cepda-volume-mute');
					cepda.$volumeBtn.text(options.texts.mute).attr('title', options.texts.mute);
				} else {
					cepda.$self.prop('muted', true);

					if(options.nativeSliders) {
						cepda.$volume.val('0');
					} else {
					cepda.$volume.slider('value', '0');
					}

					cepda.$volumeBtn.addClass('cepda-volume-mute');
					cepda.$volumeBtn.text(options.texts.unmute).attr('title', options.texts.unmute);
				}
			};

			/*
			 * Inicializar el sistema del volumen (boton y slider)
			 *
			 * Vinculamos eventos, creamos el slider jQuery
			 */
			var initVolume = function() {
				if(options.nativeSliders) {
					cepda.$volume.bind('change', function() {
						cepda.$self.prop('muted',false);
						volume = cepda.$volume.val();
						cepda.$self.prop('volume', volume);
					});
				} else {
				var volumeClass = cepda.$volume.attr('class');

				var	divVolume = '<div class="' + volumeClass + '" title="' + options.texts.volumeTitle + '"></div>';
				cepda.$volume.after(divVolume).remove();

				cepda.$volume = $('.' + volumeClass, cepda.$container);

				var volumeSliderOptions = {
					value: volume,
					orientation: options.volumeSlider,
					range: "min",
					max: 1,
					min: 0,
					step: 0.1,
					animate: true,
					slide: changeVolume,
					label: "Volume control"
				};

				cepda.$volume.slider(volumeSliderOptions);

				cepda.$volume.$handle = cepda.$volume.find('.ui-slider-handle');

				// quitar el foco manualmente al boton de subtítulos cuando se pica en el handle del slider de volumen
				$('.ui-slider-handle', cepda.$volume).click(blurCaptionBtn);
				}

				cepda.$volumeBtn.click(muteVolume);
			};

			/*
			 * Comportamiento FULLSCREEN
			 *
			 * Cambiar el tamaño del vídeo mientras estamos en modo fullscreen
			 * Lo vinculamos a window.resize
			 */
			var resizeFullscreenVideo = function() {
				cepda.$self.attr({
					'width': $(window).width(),
					'height': $(window).height()
				});
			};

			/*
			 * Evento de fullscreen
			 * para cuando se sale a saco (ESC) del modo fullscreen.
			 * debe normalizar la interficie de usuario para que esté sincronizada.
			 * Sólo nos llega cuando el navegador está en fullscreen nativo y se sale
			*/
			var fullScreenChange = function(event) {
				// actualizo los elementos visuales a la nueva disposición
				$('body').css('overflow', '');
				cepda.$controls.removeClass('fullscreen-controls');
				cepda.$caption.removeClass('fullscreen-caption');

				fullscreenMode = false;
				
				// Avisamos para que pongan la toolbar a la medida que toque
				if (options.onToolbarChanged) {
					options.onToolbarChanged(cepda, options);
				}
				
			} 
			
			/*
			 * Rutina de entrada y salida del modo fullscreen
			 *
			 * Mira si hay soporte nativo para fullscreen (siempre que mantenga la interfaz y los subtítulos)
			 * y la aplica, o bien la simula haciendo que el vídeo ocupe toda la ventana
			 * o bien sale del modo fullscreen si estaba ya en fullscreen.
			 */
			/* VARIOS ELEMENTOS ADICIONALES PARA EL MODO FULLSCREEN
			var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
			var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled;
			*/
			var goFullscreen = function() {
				
				// Primero miramos si soportamos fullscreen
				var supportsFullscreen = !cant_go_fullscreen;
				// Miramos qué versiones de navegador soporta fullscreen
				
				// Si estamos en modo fullscreen, salimos de éste
				if(fullscreenMode) {
					
				  if(document.mozCancelFullScreen && supportsFullscreen) {
				    document.removeEventListener("mozfullscreenchange", fullScreenChange);
				    document.mozCancelFullScreen();
				  } else if(document.webkitExitFullscreen && supportsFullscreen) {
				    document.removeEventListener("webkitfullscreenchange", fullScreenChange);
				    document.webkitExitFullscreen();
				  } else if(document.msCancelFullScreen && supportsFullscreen) {
				    document.removeEventListener("MSFullscreenChange", fullScreenChange);
				    document.msExitFullScreen();
				  } else if(document.exitFullscreen && supportsFullscreen) {
				    document.removeEventListener("fullscreenchange", fullScreenChange);
				    document.exitFullscreen();
				  } else {
				  	debugLog('Simulamos fullscreen');
				  	// modo pantalla completa sin fullscreen de navegador
						cepda.$self.parent().removeClass('has-fullscreen-video');
						cepda.$self.removeClass('fullscreen-video');
				    
					}
					
					// actualizo los elementos visuales a la nueva disposición
					$('body').css('overflow', '');
					cepda.$controls.removeClass('fullscreen-controls');
					cepda.$caption.removeClass('fullscreen-caption');
					if (options.fullScreenRelocateOn) {
						var $vidContainer = cepda.$self.parent();
						var playing = !cepda.$self.prop('paused');
			  		var vc = $vidContainer.detach();
			  		$("#fs_cepdavideoplayer_stub").before(vc);
			  		$("#fs_cepdavideoplayer_stub").remove();
			  		if (playing) {
			  			setTimeout(function () {
			  				playMedia();
			  			}, 200);
			  		}
			  	}

					fullscreenMode = false;

				} else { // Si no estábamos en modo fullscreen, entramos en éste
				
				  if(cepda.$self[0].mozRequestFullScreen && supportsFullscreen) {
				    cepda.$self[0].mozRequestFullScreen();
				    // Registramos el evento, con cierto retraso para que el fullscreen ya sea efectivo y no nos avisen
				    // para el caso de entrar en fullscreen
				    setTimeout(function() { document.addEventListener("mozfullscreenchange", fullScreenChange); }, 200);
				  } else if(cepda.$self[0].webkitRequestFullscreen && supportsFullscreen) {
				    cepda.$self[0].webkitRequestFullscreen();
				    // Registramos el evento, con cierto retraso para que el fullscreen ya sea efectivo y no nos avisen
				    // para el caso de entrar en fullscreen
				    setTimeout(function() { document.addEventListener("webkitfullscreenchange", fullScreenChange); }, 200);
				  } else if(cepda.$self[0].msRequestFullscreen && supportsFullscreen) {
				    cepda.$self[0].msRequestFullscreen();
				    // Registramos el evento, con cierto retraso para que el fullscreen ya sea efectivo y no nos avisen
				    // para el caso de entrar en fullscreen
				    setTimeout(function() { document.addEventListener("MSFullscreenChange", fullScreenChange); }, 200);
				  } else if(cepda.$self[0].requestFullscreen && supportsFullscreen) {
				    cepda.$self[0].requestFullscreen();
				    // Registramos el evento, con cierto retraso para que el fullscreen ya sea efectivo y no nos avisen
				    // para el caso de entrar en fullscreen
				    setTimeout(function() { document.addEventListener("fullscreenchange", fullScreenChange); }, 200);
				  }	else {
				  	// modo pantalla completa sin fullscreen de navegador
				  	debugLog('Simulamos fullscreen');
						cepda.$self.addClass('fullscreen-video');
						cepda.$self.parent().addClass('has-fullscreen-video');
						if (options.fullScreenRelocateOn) {
							var playing = !cepda.$self.prop('paused');
							var $vidContainer = cepda.$self.parent();
			  			$vidContainer.after('<div id="fs_cepdavideoplayer_stub" style="visibility:hidden; width: 1px; height 1px;">');
			  			var vc = $vidContainer.detach();
			  			vc.appendTo("body");
				  		if (playing) {
				  			setTimeout(function () {
				  				playMedia();
				  			}, 200);
				  		}
				  	}
					}			
				
					// entramos fullscreen: actualizmo los elementos visuales a la nueva posición
					$('body').css('overflow', 'hidden');
					cepda.$controls.addClass('fullscreen-controls');
					cepda.$caption.addClass('fullscreen-caption');

					fullscreenMode = true;

				}
				
				// Avisamos para que pongan la toolbar a la medida que toque
				if (options.onToolbarChanged) {
					options.onToolbarChanged(cepda, options);
				}
				
			};

			/*
			 * Comportamiento de los subtítulos
			 *
			 * Desactivando los subtítulos cuando falle la carga...
			 */
			var captions;
			var captionBtnActiveClass = 'cepda-caption-active';
			var captionBtnLoadingClass = 'cepda-caption-loading';

			var captionRadioName = 'cepdaCaptions' + uniqueID();

			var captionOff = function() {
				captions = '';
				cepda.$caption.hide();
				captionsActive = false;

				cepda.$captionBtn.removeClass(captionBtnActiveClass);
			};

			/*
			 * Actualizar los subtítulos en base a "currentTime"
			 * Obtenido y adaptado del artículo "Accessible HTML5 Video with JavaScripted captions" de Bruce Lawson
			 * http://dev.opera.com/articles/view/accessible-html5-video-with-javascripted-captions/
			 */
			var updateCaption = function() {
				// incializamos variables
				var now = cepda.$self.prop('currentTime'),
					text = '',
					i,
					captionsLength = captions.length;
				// Buscamos el subtítulo que nos toca mostrar
				for (i = 0; i < captionsLength; i++) {
					if (now >= captions[i].start && now <= captions[i].end) {
						text = captions[i].content; // yes? then load it into a variable called text
						break;
					}
				}
				// lo ponemos (si no encontramos ninguno, entonces "text" quedará vacío)
				cepda.$caption.html(text);
			};

			/*
			 * Cargar subtítulos
			 * Carga archivo en formato SRT 
			 * Recibe la url de los subtítulos como parámetro de entrada
			 */
			var loadCaption = function(url) {
				// Añadimos la clase de "cargando" para que aparezca el indicador
				cepda.$captionBtn.addClass(captionBtnLoadingClass);
				// Lanzamos la llamada AJAX para cargar el archivo
				var jqXHR = $.ajax({
					url: url,
					dataType: "text",	// indicamos que el formato es texto
					success: function(data) {
						/*
						 * Si todo va bien, parseamos el SRT
						 * Usamos el parser SRT de  Silvia Pfeiffer <silvia@siliva-pfeiffer.de>
						 * (la rutina está al final del archivo)
						 */
						 
						captions = parseSrt(data);

						// Ahora indicamos que hay que recalcular la medida de la toolbar, al añadir el botón
						// de subtítulos
						if (options.onToolbarChanged)
							options.onToolbarChanged(cepda, options);
							
						// Mostramos los subtítulos
						cepda.$caption.show();
						captionsActive = true;

						// En caso de que la media esté en pausa, actualizamos los subtítulos para que se vean los actuales
						if(cepda.$self.prop('paused')) {
							updateCaption();
						}

						cepda.$captionBtn.addClass(captionBtnActiveClass).removeClass(captionBtnLoadingClass);
					},
					error: function() {
						// Si hay algún error, desactivo el botón de subtítulos
						captionOff();
						// Aquí podríamos mostrar un mensaje al usuario, si acaso
					}
				});
			};

			/*
			 * Inicialización y carga de subtítulos
			 */
			var initCaption = function() {
				
				hasCaptions = false;
				
				// get all <track> elements
				cepda.$track = $('track', cepda.$self);

				// Si hay al menos un elemento DOM <track>, mostramos el botón
				if(cepda.$track.length) {
					cepda.$captionBtn.show();
					// Avisamos para que pongan la toolbar a la medida que toque
					// al añadir el nuevo botón
					if (options.onToolbarChanged) {
						options.onToolbarChanged(cepda, options);
					}
				} else {
					captionOff();
					cepda.$captionBtn.unbind('click');
					captions = '';
					cepda.$caption.hide();
					cepda.$captionBtn.hide();
					if (options.onToolbarChanged) {
						options.onToolbarChanged(cepda, options);
					}
					hasCaptions = false;
					return;
				}

				// Miramos si hay un track de subtítulos (el primero)
				if(cepda.$track.length) {
					
					hasCaptions = true;
					
					// Si sólo hay un elemento <track>
					// cargamos directamente los subtítulos al picar sobre el botón de subtítulos
					var tracksrc = cepda.$track.attr('src');
					cepda.$captionBtn.bind('click', function() {
						if(cepda.$captionBtn.hasClass(captionBtnActiveClass)) {
							captionOff();
						} else {
							loadCaption(tracksrc);
							cepda.$captionBtn.addClass(captionBtnActiveClass);
						}
					});

					// Cargamos los subtítulos por defecto si tenemos la opción activa
					if(options.captionsOn) {
						loadCaption(tracksrc);
						cepda.$captionBtn.addClass(captionBtnActiveClass);
					}
				}

			};

			/*
			 * Función de inicialización general (la llama el constructor)
			 * Se encarga de inicializar todo, vincular eventos y eliminar los controles nativos de la media
			 */
			var init = function() {
				

				// Avisamos para que pongan la toolbar a la medida que toque
				if (options.onToolbarChanged) {
					options.onToolbarChanged(cepda, options);
				}
				
				// Click del botón play/pause
				cepda.$playBtn.bind( (is_touch_device) ? 'touchstart' : 'click', playMedia);
				
				// BIG Play button
				if (options.bigBtnOn && !cant_show_big_play)
					cepda.$bigBtn.bind( (is_touch_device) ? 'touchstart' : 'click', playMedia);

				if (document.createElement('video').canPlayType) {
					cepda.$self.bind((is_touch_device) ? 'touchstart' : 'click', playMedia);
				}

				// Eventos del propio vídeo
				cepda.$self.bind('play', startPlayback);
				cepda.$self.bind('pause', stopPlayback);
				cepda.$self.bind('ended', stopPlayback);

				// Evento de actualización de tiempo para el slider (que se vaya actualizando)
				cepda.$self.bind('timeupdate', seekUpdate);

				// Eventos del modo fullscreen (por defecto el botón está desactivado, hasta que se empiece a reproducir el vídeo)
				cepda.$fullscreenBtn.prop('disabled',true);
				cepda.$fullscreenBtn.click(goFullscreen);

				// Inicialización del volumen (botón y slider)
				initVolume();
				
				// En iOS no podemos poner el volumen, pues iOS no deja controlar el volumen desde HTML
				if (cant_manage_volume) {
					cepda.$volumeBtn.css('display', 'none');
				}

				// Inicialización del slider de seek
				if (!options.nativeSliders)
				initSeek();

				// Evento de metadata cargada
				cepda.$self.bind('loadedmetadata', function() {
					/* Uso un intervalo de 500ms para asegurarme de que pase a estado "readyState"
					 * para saltarme un bug de webkit que hace que loadedmetadata sea llamado antes de que
					 * efectivamente la información de la duración esté disponible.
					 */
					var t = window.setInterval(function() {
								if (cepda.$self.prop('readyState') > 0) {
									loadedMetadata = true;
									updateSeek();

									clearInterval(t);
								}
							}, 500);

					initCaption();
				});
				
				// Evento de duration change
				cepda.$self.bind('durationchange', function() {
					updateSeek();
				});
				

				// Quitamos los controles nativos del vídeo/audio
				cepda.$self.prop('controls', false);

				// Si es audio, añadimos la clase "audio-player"
				if(cepda.$self.is('audio')) {
					/*
					 * Si la media es de tipo <audio>, añadimos la clase "audio-player".
					 * Por lo visto, en Opera 10.62 no se puede "tunerar" un tag <audio> con CSS
					 * por lo que lo "marcamos" con la clase "audio-player" para que pueda hacer dicho trabajo.
					 */
					cepda.$container.addClass('audio-player');
				}
				
				// Forzamos la actualización del slider de seek la primera vez (para iOS)
				if (is_ios_browser) {
					updateSeek();
				}
				if (options.onToolbarChanged)
					options.onToolbarChanged(cepda, options);
				
				// Si está en modo autoplay, ponemos el vídeo en marcha
				// (excepto para iOS, que no deja)
				if (options.autoplayOn && !is_ios_browser) {
					playMedia();
				}

				// Añadio API PUBLIC al objeto CEPDA para cambiar el vídeo
				cepda.playPause = function () { 
					playMedia();
				};

				cepda.isPlaying = function () {
					if(!this.$self.prop('paused')) {
						return true;
					} else {
						return false;
					}
				}

				cepda.getDuration = function() {
					return this.$self.prop('duration');
				}

				cepda.seek = function (seekLocation) {
					this.$self.prop('currentTime', seekLocation);
				}

				cepda.loadVideo = function(videoUrl, srtUrl, srtLang, srtLabel) {
					// Paramos el vídeo si está reproduciéndose
					if (this.isPlaying())
						this.playPause();
					// Ahora cargamos el nuevo vídeo
					this.$self.children("source").attr("src", videoUrl);
					this.$self.children("track").remove();
					if (srtUrl != null && srtUrl != undefined && srtUrl != "") {
						$("<track src=\"" + srtUrl + "\" kind=\"subtitles\" srclang=\"" + srtLang + "\" label=\"" + srtLabel + "\" />").appendTo(this.$self);
					}
					// Lanzamos la carga del vídeo (en 100 ms).
					this.$self[0].load();

				}

				cepda.resize = function(newWidth, newHeight) {
					this.$self.css({ width: newWidth + "px", height: newHeight + "px" });
					// Si es audio, fem el contenidor de la mida indicada
					if (this.$self.prop("tagName").toLowerCase() == "audio")
						this.$self.parent().css({ width: newWidth + "px" });
					if (options.onToolbarChanged)
						options.onToolbarChanged(cepda, options);
				}

				cepda.setScale = function (newScale) {
					if (options.nativeSliders == false && this.$seek != null) {
						this.$seek.slider('scale', newScale);
					}
				}

			}();

		};

		// Hacemos este proceso por todos los elementos que cumplan con el criterio de incialización
		return this.each(cepdaPlayer);
	};

})(jQuery);

/*
 * parseSrt function
 * JavaScript SRT parser by Silvia Pfeiffer <silvia@siliva-pfeiffer.de>
 * http://silvia-pfeiffer.de/
 *
 * Tri-licensed under MPL 1.1/GPL 2.0/LGPL 2.1
 *  http://www.gnu.org/licenses/gpl.html
 *  http://www.gnu.org/licenses/lgpl.html
 *  http://www.mozilla.org/MPL/
 *
 * The Initial Developer of the Original Code is Mozilla Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Silvia Pfeiffer <silvia@siliva-pfeiffer.de>
 *
 *
 */
function parseSrt(data) {
	var srt = data.replace(/\r+/g, ''); // remove dos newlines
	srt = srt.replace(/^\s+|\s+$/g, ''); // trim white space start and end
	srt = srt.replace(/<[a-zA-Z\/][^>]*>/g, ''); // remove all html tags for security reasons

	// get captions
	var captions = [];
	var caplist = srt.split('\n\n');
	for (var i = 0; i < caplist.length; i=i+1) {
		var caption = "";
		var content, start, end, s;
		caption = caplist[i];
		s = caption.split(/\n/);
		if (s[0].match(/^\d+$/) && s[1].match(/\d+:\d+:\d+/)) {
			// ignore caption number in s[0]
			// parse time string
			var m = s[1].match(/(\d+):(\d+):(\d+)(?:,(\d+))?\s*--?>\s*(\d+):(\d+):(\d+)(?:,(\d+))?/);
			if (m) {
				start =
				(parseInt(m[1], 10) * 60 * 60) +
				(parseInt(m[2], 10) * 60) +
				(parseInt(m[3], 10)) +
				(parseInt(m[4], 10) / 1000);
				end =
				(parseInt(m[5], 10) * 60 * 60) +
				(parseInt(m[6], 10) * 60) +
				(parseInt(m[7], 10)) +
				(parseInt(m[8], 10) / 1000);
			} else {
				// Unrecognized timestring
				continue;
			}
			// concatenate text lines to html text
			content = s.slice(2).join("<br>");
		} else {
			// file format error or comment lines
			continue;
		}
		captions.push({start: start, end: end, content: content});
	}

	return captions;
}
